# Command
GPU에는 명렬 대기열 (Command queue)이 하나 있습니다. CPU는 그리기 명령들이 담긴 명령 목록(command list)을 Direct3D API를 통해서 그 대기열에 제출합니다. 여기서 중요한 점은, 일단의 명령들을 명령 대기열에 제출했다고 해도, 그 명령들을 GPU가 즉시 실행하는 것은 아니라는 점입니다. 명령들은 GPU가 처리할 준비가 되어야 비로소 실행되기 시작합니다.

## ID3D12CommandQueue

	m_d3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(m_commandQueue.ReleaseAndGetAddressOf()))

명령 대기열을 생성합니다.

	m_commandQueue->ExecuteCommandLists(1, CommandListCast(m_commandList.GetAddressOf()))
명령 목록에 있는 명령들을 대기열에 추가합니다.

## ID3D12GraphicsCommandList
ID3D12GraphicsCommandList 에는 명령들을 명령 목록에 추가하는 여러 함수가 있습니다.

    commandList->RSSetViewports(1, &viewport);
    commandList->ClearRenderTargetView(rtvDescriptor, Colors::CornflowerBlue, 0, nullptr);
    commandList->DrawIndexedInstanced(36, 1, 0, 0, 0, 0);
뷰포트를 설정하고 렌더 타깃 뷰를 지우고, 그리기 호출을 실행하는 명령 예시입니다.
 

	m_commandList->Close()
명령을 다 추가했다면 Close 함수를 호출합니다.

## ID3D12CommandAllocator

명령 목록에 추가된 명령들은 ID3D12CommandAllocator로 선언된 할당자 메모리에 저장된다.

    for (UINT n = 0; n < m_backBufferCount; n++)
    {
        ThrowIfFailed(m_d3dDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(m_commandAllocators[n].ReleaseAndGetAddressOf())));

        wchar_t name[25] = {};
        swprintf_s(name, L"Render target %u", n);
        m_commandAllocators[n]->SetName(name);
    }
  
후면 버퍼 개수만큼 할당자를 만드는 코드입니다.

    ThrowIfFailed(m_commandAllocators[m_backBufferIndex]->Reset());
    ThrowIfFailed(m_commandList->Reset(m_commandAllocators[m_backBufferIndex].Get(), nullptr));
  새로운 프레임에 명령을 추가하기 전에 할당자를 비워주는 코드입니다.

	D3D12_COMMAND_LIST_TYPE_BUNDLE
`D3D12_COMMAND_LIST_TYPE_BUNDLE` 열거형을 사용하면 드라이버는 렌더링 도중에 실행이 최적화되도록 번들의 명령들을 전처리합니다. 응용 프로그램을 프로파일링해서 특정 명령 목록들을 구축하는 데 시간이 오래 걸린다는 점을 발견했을 때 사용해볼 수 있습니다.

명령들을 여러 명령 목록에 동시에 기록할 수는 없습니다. 현재 명령들을 추가하는 명령 목록을 제외한 모든 명령 목록은 닫혀 있어야 합니다. 같은 할당자로 두 명령 목록을 연달아 생성하면 예외가 발생합니다.

## 명령 목록을 이용한 다중 스레드 활용
명령 목록은 여러 스레드에서 병렬적으로 구성할 수 있습니다. 성능 상의 이유로 동시에 기록할 수 있는 명령 목록의 최대 개수를 반드시 초기화 시점에서 설정해야 합니다.